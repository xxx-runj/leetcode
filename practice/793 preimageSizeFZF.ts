// 阶乘函数后 K 个零
function preimageSizeFZF(k) {
    function f(k) {
        function check(n: bigint) {
            let cnt = 0n;
            while (n !== 0n) {
                cnt += n / 5n;
                n = n / 5n;
            }
            return cnt >= k;
        }
        let l = 0n;
        let r = 5n * BigInt(k);
        while (l <= r) {
            const mid = l + (r - l) / 2n;
            if (check(mid)) {
                // 5的个数 >= k，说明 n 还可以再小一点
                r = mid - 1n;
            } else {
                l = mid + 1n;
            }
        }
        // l的左边都是个数小于k的
        return l;
    }
    return f(k+1) - f(k);
}
/**
 * 真复杂啊!!!!!
 *
 * 对于一个阶乘而言，n! = 1 * 2 * ... * n
 * 末尾 0 的个数和 10 有关，一个数乘以 1个10，末尾就多 1个0，乘以 2个10 即 10*10，末尾就多 2个0
 * 而 10 可以因式分解为 2*5，因此一个数乘以 1个2*5，末尾就多 1个0，乘以 2个2*5 即 2*5*2*5，末尾就多 2个0
 * 哪些数因式分解后包含 5 呢？5 10 15 20 25 30 ... 5*n
 * 哪些数因此分解后包含 2 呢？2 4 6 8 10 12 14 ... 2*n
 * 可以看出，2的个数是大于5的
 * 因此一个数字如果末尾含0，那么它的因式分解一定包含 (2^p * 5^q) 且 p >= q
 * 故末尾0的个数 等于 q
 * 随着 n 的增大，其所能分解出来的 5 的个数必然是递增的
 * 现在我们要统计 1、2、3、 ... 、n 中，每个数字因式分解后 5的个数 之和
 * 5 = 1 * 5（1个5）
 * 10 = 2 * 5（1个）
 * 15 = 3 * 5（1个）
 * 20 = 4 * 5（1个）
 * 25 = 5 * 5（2个5） 50 = 2 * 5 * 5（2个5） 75 = 3 * 5 * 5（2个5）...
 * 30 = 6 * 5（1个）
 * 125 = 5 * 5 * 5（3个5）250 = 2 * 5 * 5 * 5（3个5） ...
 * 可以看出：
 *      每隔 5，都会有1个5；（假设此时出现了 k个5，那么值为 5k，这就是 n 的上界）
 *      每隔25，都会有2个5；
 *      每隔125，都会有3个5，以此类推
 */

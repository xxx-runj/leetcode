## 1. vue3 相比 vue2 的优势
- 速度更快，性能更好
    - 数据响应劫持
    - diff算法优化
    - 虚拟dom重写
    - 静态提升
    - 事件侦听器缓存
    - SSR 渲染优化<font color="red">（不要提这个，无法深入回答）</font>
- 体积更小（tree-shaking，按需编译）
- 更易维护
- 更好的 ts 支持

## 2. vue3 做了哪些优化方案
    可以从源码、性能（体积、编译、数据劫持）、语法API 三个方面回答
- 源码
    - 使用 monorepo 管理代码，将不同的模块拆分到不同的子目录下
    - 支持 typescript，更好的类型推导，编译阶段进行类型检查
- 性能
    - tree-shaking，减小打包体积
    - 虚拟dom重写、diff算法优化、静态提升
    - 更好的响应式系统（proxy 代替 Object.defineProperty）
- 语法API
    - composition api，代码更灵活可复用


## 3. vue3 里为什么要用 proxy 代替 defineProperty
- 无需递归遍历数据，初始化速度更快
- 支持对数组API方法进行监听
- 支持监听新增属性、删除属性

## 4. vue3 diff 算法
采用 双端法 + 最长递增子序列

## 5. 对SPA的理解？和 MPA 的差别
SPA即单页应用，切换路由时，只进行局部刷新，公共资源仅需加载一次
优点：页面切换快
缺点：首屏时间慢（请求一次html、请求一次js）、SEO不友好

MPA即多页应用，有多个HTML页面，页面间独立
优点：首次加载较快（只加载当前页面所需资源）、SEO原生友好
缺点：页面切换较慢（页面每次切换都需要请求html）

#### 5.1 SEO
即搜索引擎优化，通过优化网站结构、内容、关键词等让网页更容易被搜索引擎搜到
#### 5.2 为什么SPA对SEO不友好
因为SPA的内容是靠JS渲染出来的，搜索引擎抓取的时候，可能读不到页面中的内容、关键词等信息
#### 5.3 怎么让HTML文件对SEO更友好
- 设置title标签、设置meta标签 description、keywords等
- 使用语义化标签，比如 `<p>、<h1>、<section>`
- 提供结构清晰的文本内容
- 图片加 alt 文本
#### 5.4 SPA首屏加载慢怎么解决
- 减小入口文件体积，路由懒加载（只加载当前路由下的组件）
- UI框架按需加载
- 静态资源缓存
- 图片资源压缩

## 6. 为什么不建议在一个元素上同时使用v-if 和 v-for
在同一个元素上使用时，v-for的优先级比v-if高，每次都会先进行循环再进行条件判断，浪费性能

## 7. vue双向绑定
数据变化 ——> 视图变化：利用数据响应劫持 \
视图变化 ——> 数据变化：利用DOM事件监听

## 8. 说说对 vue key 的理解
在vue中，key的作用是帮助 diff 算法更高效、更准确地对比和复用 DOM 节点。\
有 key 的 diff 是基于 节点身份（identity）做判断 \
无 key 的 diff 是基于 位置顺序 做就地复用

## 9. 虚拟DOM是什么？它的作用？
虚拟DOM是用来描述真实DOM的一个JSON对象，它是对真实DOM的抽象。
- 结合diff算法，减少JS操作真实DOM带来的性能消耗
- 抽象了原本的渲染过程，实现了跨平台的能力

## 10. tree-shaking是什么
移除未被用到的代码，按需编译。它做了两件事：
- 构建模块依赖（利用 ES Module 静态结构）
- 标记有用的、移除未使用的代码

## 11. webpack
webpack是一个前端模块打包工具，输入各种前端资源 → 经过处理 → 输出优化过的文件，供浏览器使用
- 统一模块化（支持 CommonJS、AMD、ESM 等模块格式
- 自动依赖分析（自动分析所有依赖，生成依赖图
- 构建优化（代码压缩、分割、按需加载
- 集成化开发体验（开发服务器、热更新

## 12. Rollup
rollup是一个javascript模块打包工具，更适合打包库、SDK。原生支持ESM

## 13. Babel
babel是一个JS编译器，将JS代码转换成另一版本的JS，让它在浏览器正常运行。
- 将JS新语法转换成浏览器支持的旧版本
- jsx、ts转换（针对typescript，不做类型检查，只做语法转换）
- polyfill（垫片），让旧环境支持新API（如 Promise 等

## 14. vite
vite是一个前端构建工具，利用浏览器原生ESM支持，启动时按需加载。
- 开发环境：
    - 浏览器请求.vue文件
    - vite利用`@vitejs/plugin-vue`解析SFC
    - template部分转成 render 函数，`<script lang="ts">`部分交给 esbuild 转译，style部分通过内置的css处理逻辑，转成js模块
    - 主模块里将以上三个模块引入(import)，由浏览器去加载对应的模块文件
- 生产环境：
    - vue sfc: 由插件完成编译
    - 打包与优化（将模块整合成少量文件、tree-shaking、代码分块、代码压缩）：由rollup完成

## 15. 开发环境：vite热更新 VS webpack热更新
开发服务器与客户端利用 websocket 建立连接
- vite
    - vite监控项目源码，当文件变化时，重新编译对应模块
    - dev server通过 websocket 向浏览器发送 HMR 消息，通知哪个模块已更新
    - 浏览器接收到消息后，用 import() 动态请求 已经被即时编译好的模块
    - 模块加载完成后替换旧模块
    - 注意：以上过程是没有 打包 行为的哦
- webpack
    - 监控项目文件变化，对受影响的模块重新编译、打包（update chunk）
    - 生成 HMR 补丁代码，补丁信息里包括：模块ID、新的模块函数、更新类型
    - 通过 webSocket 将补丁信息发送到浏览器
    - 客户端收到消息后，替换模块函数

## 16. vue依赖收集、触发发生在哪个阶段
在运行时渲染阶段。
- 编译时：负责把模板编译为渲染函数 render function
- 运行时：执行渲染函数，做响应式追踪、diff更新

## 17. computed如何实现的？为什么要通过.value来获取值？
它有点像一个特殊的 Ref 类，内部通过 value 和 dirty 来实现缓存。  
- 为了统一响应式API
- 方便做依赖收集（proxy对对象进行拦截，通过.value可以访问对象属性）

## 18. 使用vue的过程中，要注意什么？
- 正确使用 v-if v-show
- 列表渲染时增加稳定的key
- 避免在模板里写复杂运算
- 使用computed来代替频繁计算
- 合理拆分组件
- 路由懒加载、组件懒加载、按需引入UI库









